В хэш-таблицах используются различные методы для обработки коллизий, такие как:
Метод цепочек (chaining): Каждый индекс массива содержит список (или другую структуру), в который добавляются все элементы, чьи ключи были преобразованы в один и тот же индекс.
Открытая адресация (open addressing): В случае коллизии элементы размещаются в другой ячейке массива согласно определённой стратегии поиска (например, линейное пробирование).

Линейное пробирование (Linear Probing):
При коллизии мы просто проверяем следующую ячейку массива (с шагом 1), пока не найдём свободную ячейку.
  
Квадратичное пробирование (Quadratic Probing):
Вместо линейного сдвига, при коллизии мы увеличиваем шаг квадратично. Индексы проверяются с возрастанием на 1, 4, 9, 16 и так далее.
	
Двойное хэширование (Double Hashing):
Для пробирования используется вторая хэш-функция. Если первая хэш-функция привела к коллизии, то второе значение хэшируется с помощью другой хэш-функции, и шаг пробирования определяется на основе этого результата.

LinkedHashMap — это реализация хэш-таблицы, которая сохраняет порядок вставки элементов. Внутренне он использует связный список (linked list), чтобы запомнить порядок, в котором пары ключ-значение были добавлены в карту.
В основе лежит хэш-таблица, а также связный список для поддержания порядка элементов. Элементы сохраняются по хэш-коду, как в HashMap, но также связываются между собой через список. 
LinkedHashMap подходит, если нужно сохранять порядок элементов или реализовать структуру с порядком вставки и быстрым доступом за O(1).

TreeMap — это реализация карты, которая хранит ключи в отсортированном порядке. В основе TreeMap лежит красно-чёрное дерево (самобалансирующееся двоичное дерево), которое гарантирует, что элементы будут отсортированы по ключам.
Элементы в TreeMap всегда хранятся в порядке сортировки ключей. По умолчанию сортировка происходит по естественному порядку (Comparable), но можно задать собственный порядок с помощью объекта Comparator.
Принцип работы: TreeMap хранит элементы как узлы в дереве. Вставка и доступ к элементам поддерживают упорядоченность структуры.
TreeMap лучше использовать, если важно хранить данные в отсортированном порядке или нужно работать с диапазонами ключей, но операции будут происходить за O(log n).
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
  
Очередь — это структура данных, которая работает по принципу FIFO (First-In-First-Out), что означает, что первый элемент, добавленный в очередь, будет первым удалён из неё. В Java очередь представлена интерфейсом Queue, который является частью коллекций в пакете java.util.


PriorityQueue — очередь с приоритетом, которая упорядочивает элементы по естественному порядку (для классов, реализующих интерфейс Comparable) или с помощью переданного компаратора. Элементы с более высоким приоритетом извлекаются первыми, независимо от порядка их добавления.
ArrayDeque — двусторонняя очередь (двунаправленная), которая эффективна для работы как с обычными операциями очереди (FIFO), так и с операциями стека (LIFO). Она работает быстрее, чем LinkedList для очередей с ограничением по размеру.
Deque (Double-Ended Queue) — это расширенная версия очереди, которая поддерживает добавление и удаление элементов как с головы, так и с хвоста. В Java интерфейс Deque реализуется классами LinkedList и ArrayDeque.

BlockingQueue — это специальный тип очереди, который используется в многопоточных приложениях. Он поддерживает методы, которые блокируют потоки при попытке добавить элемент в заполненную очередь или при попытке извлечь элемент из пустой очереди.
put(E e): добавляет элемент в очередь, блокируя поток, если очередь полна.
take(): извлекает элемент из очереди, блокируя поток, если очередь пуста.


Добавление элементов в Queue:
add(E e)	Добавляет элемент в очередь	Выбрасывает IllegalStateException, если очередь полна
offer(E e)	Добавляет элемент в очередь	Возвращает false, если очередь полна
Удаление элементов		
remove()	Удаляет и возвращает первый элемент (голову) очереди	Выбрасывает NoSuchElementException, если очередь пуста
poll()	Удаляет и возвращает первый элемент (голову) очереди	Возвращает null, если очередь пуста
Просмотр элементов		
element()	Возвращает первый элемент (голову) очереди без удаления	Выбрасывает NoSuchElementException, если очередь пуста
peek()	Возвращает первый элемент (голову) очереди без удаления	Возвращает null, если очередь пуста

Работа с Deque:
Добавление элементов
addFirst(E e)	Добавляет элемент в начало очереди	Выбрасывает IllegalStateException, если очередь полна
addLast(E e)	Добавляет элемент в конец очереди	Выбрасывает IllegalStateException, если очередь полна
offerFirst(E e)	Добавляет элемент в начало очереди	Возвращает false, если очередь полна
offerLast(E e)	Добавляет элемент в конец очереди	Возвращает false, если очередь полна
Удаление элементов		
removeFirst()	Удаляет и возвращает первый элемент (голову) очереди	Выбрасывает NoSuchElementException, если очередь пуста
removeLast()	Удаляет и возвращает последний элемент (хвост) очереди	Выбрасывает NoSuchElementException, если очередь пуста
pollFirst()	Удаляет и возвращает первый элемент (голову) очереди	Возвращает null, если очередь пуста
pollLast()	Удаляет и возвращает последний элемент (хвост) очереди	Возвращает null, если очередь пуста
Просмотр элементов		
getFirst()	Возвращает первый элемент (голову) очереди без удаления	Выбрасывает NoSuchElementException, если очередь пуста
getLast()	Возвращает последний элемент (хвост) очереди без удаления	Выбрасывает NoSuchElementException, если очередь пуста
peekFirst()	Возвращает первый элемент (голову) очереди без удаления	Возвращает null, если очередь пуста
peekLast()	Возвращает последний элемент (хвост) очереди без удаления	Возвращает null, если очередь пуста
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Объединение (Union):
Объединяет два множества, добавляя все уникальные элементы из обоих.
Можно использовать метод addAll(Collection<? extends E> c)

Пересечение (Intersection):
Оставляет только те элементы, которые есть в обоих множествах.
Можно использовать метод retainAll(Collection<?> c)

Разность (Difference):
Удаляет элементы из одного множества, которые присутствуют в другом.
Можно использовать метод removeAll(Collection<?> c)
