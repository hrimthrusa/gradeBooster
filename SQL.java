1. Работа с индексами в БД
Индексы — это структуры данных, которые ускоряют поиск строк в таблицах. Они работают подобно указателям в книгах, позволяя быстро находить нужные данные без необходимости сканирования всей таблицы.

Типы индексов:

Уникальные индексы — предотвращают дубликаты значений в столбце.
Ненадежные индексы — допускают дубликаты значений.
Полнотекстовые индексы — используются для выполнения полнотекстового поиска.
Индексы на нескольких столбцах — позволяют индексировать комбинацию столбцов.
Преимущества индексов:

Ускоряют выполнение запросов.
Упрощают операции сортировки и фильтрации.
  
Недостатки:
Увеличивают время вставки, обновления и удаления записей.
Занимают дополнительное пространство в памяти.
  
2. Сиквенсы
Сиквенсы — это объекты БД, которые используются для генерации уникальных значений, часто применяемых в качестве первичных ключей.

Генерация:
Сиквенсы создаются с помощью команды CREATE SEQUENCE.
Значения могут быть увеличены автоматически с заданным шагом.

CREATE SEQUENCE seq_example
START WITH 1
INCREMENT BY 1;
Использование: Для получения следующего значения сиквенса можно использовать NEXTVAL.

SELECT NEXTVAL('seq_example');
Особенности:
Сиквенсы независимы от таблиц, что позволяет использовать их в разных контекстах.
Они обеспечивают уникальность даже при параллельном доступе.

3. Агрегатные функции
Агрегатные функции обрабатывают набор значений и возвращают одно значение.

Основные агрегатные функции:
COUNT() — возвращает количество строк, которые соответствуют условиям.
MAX() — возвращает максимальное значение.
MIN() — возвращает минимальное значение.
AVG() — возвращает среднее значение.
SUM() — возвращает сумму значений.

SELECT COUNT(*), MAX(salary), MIN(salary), AVG(salary), SUM(salary)
FROM employees;

4. Группировки
GROUP BY: Используется для группировки результатов по одному или нескольким столбцам.

SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id;
HAVING: Применяется для фильтрации групп после выполнения агрегатных функций.

SELECT department_id, COUNT(*)
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;

5. Преобразования
CAST(): Функция для преобразования одного типа данных в другой.

SELECT CAST(salary AS VARCHAR) FROM employees;
CONVERT(): Также используется для преобразования, но с немного другой синтаксисом.

SELECT CONVERT(VARCHAR, salary) FROM employees;

6. Вложенные запросы
Вложенные запросы (или подзапросы) — это запросы, находящиеся внутри другого SQL-запроса.

SELECT *
FROM employees
WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1000);

7. Конструкция WITH
Конструкция WITH позволяет создавать временные подзапросы, которые можно использовать в основном запросе. Это улучшает читаемость и структуру SQL-запросов.

WITH dept_summary AS (
    SELECT department_id, COUNT(*) AS emp_count
    FROM employees
    GROUP BY department_id
)
SELECT *
FROM dept_summary
WHERE emp_count > 5;

8. CASE-WHEN
Оператор CASE позволяет выполнять условные проверки в SQL-запросах.

SELECT employee_id,
       CASE
           WHEN salary > 10000 THEN 'High'
           WHEN salary BETWEEN 5000 AND 10000 THEN 'Medium'
           ELSE 'Low'
       END AS salary_category
FROM employees;

9. Переменные
Переменные позволяют хранить значения для использования в SQL-запросах, обычно в процедурах и функциях. В SQL, как правило, используются переменные в хранимых процедурах или функциях.

DECLARE @salary_threshold INT;
SET @salary_threshold = 5000;

SELECT *
FROM employees
WHERE salary > @salary_threshold;
