Функциональный интерфейс (или SAM-интерфейс, от Single Abstract Method) в Java — это интерфейс, который содержит ровно один абстрактный метод. Такие интерфейсы можно использовать как целевые типы для лямбда-выражений и ссылок на методы. Функциональный интерфейс может также содержать другие методы, такие как дефолтные или статические методы, но у него обязательно должен быть один абстрактный метод.

Функциональные интерфейсы играют ключевую роль в функциональном программировании на Java, начиная с версии Java 8, когда были добавлены лямбда-выражения.

@FunctionalInterface
public interface MyFunctionalInterface {
    void doSomething();  // Единственный абстрактный метод
}
Функциональный интерфейс можно использовать с лямбда-выражением:


MyFunctionalInterface action = () -> System.out.println("Doing something!");
action.doSomething();  // Выведет: "Doing something!"

Определяющие правила функционального интерфейса:
Один абстрактный метод: Интерфейс должен содержать ровно один абстрактный метод. Этот метод будет использоваться для лямбда-выражения или ссылки на метод.

@FunctionalInterface
public interface MyInterface {
    void performAction();  // Единственный абстрактный метод
}
Допустимость других методов:

Дефолтные методы могут присутствовать в функциональном интерфейсе. Они могут содержать реализацию и не влияют на статус функционального интерфейса.
Статические методы также могут присутствовать и не влияют на статус функционального интерфейса.
Если интерфейс наследует другие интерфейсы, он всё равно может оставаться функциональным, если в сумме после наследования у него будет ровно один абстрактный метод.

Основные различия:
Характеристика	Абстрактный класс	                                                                                                    Интерфейс
Наследование	Может наследовать только один класс (так как Java поддерживает одиночное наследование).                                	Класс может реализовывать множество интерфейсов.
Модификаторы доступа методов	Может иметь методы с любыми модификаторами доступа (public, protected, private).	                    Все методы интерфейсов по умолчанию public.
Абстрактные методы	Может содержать абстрактные методы (без реализации) и методы с реализацией.	                                        До Java 8 содержал только абстрактные методы. Начиная с Java 8, может содержать дефолтные методы (с реализацией) и статические методы.
Конструкторы	Может содержать конструкторы.	                                                                                        Не может содержать конструкторы.
Поля (состояние)	Может содержать поля и методы, работающие с состоянием (поля могут быть не только final).	                        Может содержать только статические финальные переменные (константы).
Множественное наследование	Не поддерживает множественное наследование классов.	                                                        Поддерживает множественное наследование интерфейсов.
Когда использовать	Используется, когда нужно предоставить частичную реализацию и общий функционал.	                                    Используется для определения контрактов, которые классы обязаны реализовать.

Используйте интерфейсы, когда:
Вы хотите определить контракт (набор методов), который должны реализовать классы.
Ваши классы могут быть разными по сути, но должны реализовывать одно и то же поведение (например, классы Bird и Airplane могут реализовывать интерфейс Flyable).
Вам нужно обеспечить поддержку множественного наследования.
    
Используйте абстрактные классы, когда:
Вы хотите предоставить частичную реализацию методов или разделить состояние между подклассами.
Ваши классы логически связаны (например, все классы-наследники — это разные виды транспортных средств).
Ваши классы могут делить общую функциональность и поведение (например, все подклассы могут иметь общие поля, такие как скорость).

В Java, начиная с версии 8, были введены функциональные интерфейсы, которые позволяют передавать поведение в виде параметров, поддерживая стиль функционального программирования. Среди них основное внимание уделяется следующим интерфейсам: Predicate, Supplier, Consumer и Function. Эти интерфейсы предоставляются в пакете java.util.function и имеют важное значение для работы с потоками данных, коллекциями и функциональными операциями.

1. Predicate
Predicate — это функциональный интерфейс, который принимает один аргумент и возвращает значение типа boolean. Его основная цель — проверка условия (логическая проверка).

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

Предикат используется, когда нужно проверить истинность или ложность какого-либо условия.
Пример: фильтрация данных в коллекции или проверка входных данных.
Пример использования Predicate:

Predicate<Integer> isEven = (n) -> n % 2 == 0;

System.out.println(isEven.test(4));  // true
System.out.println(isEven.test(7));  // false
Здесь isEven проверяет, является ли число четным.
Дополнительные методы:
and(): объединяет два предиката, выполняя логическое "И".
or(): объединяет два предиката, выполняя логическое "ИЛИ".
negate(): возвращает предикат с противоположным условием.

Predicate<Integer> isOdd = isEven.negate();  // проверка на нечетность

2. Supplier
Supplier — это функциональный интерфейс, который ничего не принимает, но возвращает значение. Он используется, когда нужно что-то "поставить" (сгенерировать или предоставить) без необходимости передавать входные данные.

@FunctionalInterface
public interface Supplier<T> {
    T get();
}

Supplier полезен, когда нужно отложенно получить какое-то значение или объект, который может быть создан на основе внутренней логики.
Пример: генерация случайных чисел или создание новых объектов.
Пример использования Supplier:

Supplier<String> randomStringSupplier = () -> UUID.randomUUID().toString();
System.out.println(randomStringSupplier.get());  // Выведет случайную строку
System.out.println(randomStringSupplier.get());  // Выведет другую случайную строку
Здесь randomStringSupplier генерирует случайную строку (UUID) каждый раз, когда вызывается метод get().
    
3. Consumer
Consumer — это функциональный интерфейс, который принимает один аргумент, но ничего не возвращает. Он используется, когда нужно выполнить какое-то действие над переданным объектом (например, вывести на экран, записать в лог или изменить состояние объекта).

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

Consumer полезен, когда нужно выполнить действие с входными данными, но результат не требуется возвращать.
Пример: вывод данных на экран или запись в файл.

Consumer<String> printer = (s) -> System.out.println(s);
printer.accept("Hello, World!");  // Выведет: Hello, World!
Здесь printer принимает строку и выводит её на экран.
Дополнительные методы:
andThen(): позволяет комбинировать несколько Consumer'ов, выполняя их последовательно.

Consumer<String> printerUppercase = (s) -> System.out.println(s.toUpperCase());
printer.andThen(printerUppercase).accept("hello");  // Выведет: hello и затем HELLO

4. Function
Function — это функциональный интерфейс, который принимает один аргумент и возвращает результат. Он используется для преобразования одного типа данных в другой.

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

Function полезен, когда нужно выполнить преобразование данных или вычислить что-то на основе входного значения.
Пример: преобразование строки в число или вычисление длины строки.

Function<String, Integer> stringLength = (s) -> s.length();

System.out.println(stringLength.apply("Hello"));  // 5
Здесь stringLength принимает строку и возвращает её длину.
Дополнительные методы:
andThen(): позволяет выполнять несколько функций последовательно, используя результат первой функции как входные данные для следующей.
compose(): выполняет несколько функций в обратном порядке (сначала переданная функция, затем текущая).
Пример с использованием andThen():

Function<String, Integer> stringLength = (s) -> s.length();
Function<Integer, Integer> square = (n) -> n * n;
Function<String, Integer> lengthSquared = stringLength.andThen(square);

System.out.println(lengthSquared.apply("Hello"));  // 25
Краткое сравнение и ключевые моменты:
Интерфейс	Входной параметр	Возвращаемое значение	Основное назначение
Predicate	Один параметр	boolean	Логическая проверка
Supplier	Нет	Один результат	Генерация или предоставление значения
Consumer	Один параметр	Нет	Выполнение действия над входным параметром
Function	Один параметр	Один результат	Преобразование или вычисление значения
Когда что использовать:
Predicate: когда нужно проверять условия или фильтровать данные. Например, фильтрация списка чисел для нахождения чётных чисел.
Supplier: когда нужно лениво (отложенно) предоставить данные или объекты. Например, генерация случайных чисел, загрузка данных из внешних источников.
Consumer: когда нужно выполнить действие над данными без возвращения результата. Например, обработка элементов коллекции, вывод на экран, запись в файл.
Function: когда нужно преобразовать данные из одного типа в другой. Например, преобразование строки в число, вычисление значения на основе данных.
Эти функциональные интерфейсы обеспечивают гибкость и выразительность для написания краткого и читаемого кода, особенно при работе с потоками данных и коллекциями.
