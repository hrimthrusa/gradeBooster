1. Single Responsibility Principle (SRP) — Принцип единственной ответственности
Класс должен иметь только одну причину для изменения, то есть выполнять только одну задачу. Каждый класс должен отвечать только за одну часть функциональности программы, что делает его более устойчивым к изменениям и ошибкам.

2. Open/Closed Principle (OCP) — Принцип открытости/закрытости
Классы должны быть открыты для расширения, но закрыты для модификации. То есть при добавлении новой функциональности класс не должен изменяться. Вместо этого нужно создать новый класс или метод.

3. Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков
Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения корректности программы. Если класс B является подклассом класса A, то объекты класса A можно заменить объектами класса B без изменения поведения программы.

4. Interface Segregation Principle (ISP) — Принцип разделения интерфейсов
Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше создать несколько узкоспециализированных интерфейсов, чем один универсальный. Таким образом, класс использует только те методы, которые ему необходимы.
  
5. Dependency Inversion Principle (DIP) — Принцип инверсии зависимостей
Высокоуровневые модули не должны зависеть от низкоуровневых. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей; детали должны зависеть от абстракций. DIP снижает зависимость между классами и делает их более гибкими.

Пример:
public interface MessageSender {
    void sendMessage(String message);
}

public class EmailSender implements MessageSender {
    @Override
    public void sendMessage(String message) {
        System.out.println("Email sent: " + message);
    }
}

public class NotificationService {
    private MessageSender sender;

    public NotificationService(MessageSender sender) {
        this.sender = sender;
    }

    public void notifyUser(String message) {
        sender.sendMessage(message);
    }
}
Теперь, чтобы изменить способ отправки сообщений, нужно просто заменить EmailSender на другой класс, который реализует интерфейс MessageSender, не изменяя класс NotificationService.

SRP — каждый класс отвечает за одну задачу.
OCP — классы можно расширять без изменения существующего кода.
LSP — подклассы должны заменять базовые классы без нарушений.
ISP — интерфейсы должны быть специализированными, а не универсальными.
DIP — классы должны зависеть от абстракций, а не конкретных реализаций.

Порождающие шаблоны (Creational Patterns)
Эти шаблоны помогают управлять созданием объектов, делая процесс создания более гибким и независимым от конкретных классов, создаваемых объектов. Основные порождающие паттерны:

Factory Method — Определяет интерфейс для создания объектов, позволяя подклассам изменять тип создаваемого объекта.
Abstract Factory — Создает набор связанных объектов без необходимости указывать их конкретные классы.
Singleton — Гарантирует, что у класса есть только один экземпляр и предоставляет к нему глобальную точку доступа.
Builder — Разделяет конструирование сложного объекта от его представления, позволяя создавать разные представления.
Prototype — Позволяет создавать объекты путем клонирования существующих объектов.
  
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

Структурные шаблоны (Structural Patterns)
Эти шаблоны помогают организовать классы и объекты в крупные структуры. Структурные паттерны важны для построения отношений между объектами и обеспечивают гибкие и эффективные структуры.
Adapter — Позволяет объектам с несовместимыми интерфейсами работать вместе.
Bridge — Разделяет абстракцию и реализацию, что позволяет им изменяться независимо.
Composite — Компонует объекты в древовидные структуры, представляя иерархию “часть-целое”.
Decorator — Динамически добавляет новую функциональность объекту.
Facade — Предоставляет упрощенный интерфейс к сложной системе.
Flyweight — Минимизирует использование памяти за счет совместного использования большого количества мелких объектов.
Proxy — Замещает другой объект и контролирует доступ к нему.

Поведенческие шаблоны (Behavioral Patterns)
Эти шаблоны помогают организовать взаимодействие между объектами. Они управляют коммуникацией и обязанностями между объектами и классами.

Chain of Responsibility — Передает запрос последовательно по цепочке обработчиков до тех пор, пока не будет найден обработчик.
Command — Заворачивает запросы в объекты, позволяя параметризовать клиентские объекты с запросами.
Interpreter — Интерпретирует грамматику и оценивает ее в рамках контекста.
Iterator — Предоставляет способ последовательного доступа к элементам коллекции.
Mediator — Обеспечивает взаимодействие между объектами, избегая их прямых ссылок друг на друга.
Memento — Захватывает и сохраняет внутреннее состояние объекта, чтобы его можно было восстановить позднее.
Observer — Создает механизм подписки, который позволяет одним объектам следить и реагировать на события, происходящие в других объектах.
State — Позволяет объекту изменять свое поведение при изменении его внутреннего состояния.
Strategy — Определяет семейство алгоритмов, которые можно подменять друг другом.
Template Method — Определяет скелет алгоритма в методе, оставляя реализацию отдельных шагов подклассам.
Visitor — Позволяет добавлять новые операции для объектов, не изменяя их классы.


Service — Сервисный слой, содержит бизнес-логику приложения. Сервисы часто используют объекты DAO для доступа к данным и реализуют основную логику приложения.
Repository — Репозиторий управляет хранением объектов в БД. Применяется в шаблоне Repository для хранения объектов в БД.
DAO (Data Access Object) — Паттерн для взаимодействия с базой данных. DAO инкапсулирует логику доступа к данным, скрывая детали взаимодействия с базой данных.
DTO (Data Transfer Object) — Объекты, которые передаются между слоями приложения или по сети. Служат для переноса данных, минимизируя количество вызовов и экономя ресурсы системы.

KISS (Keep It Simple, Stupid)
Этот принцип предполагает, что решения должны быть максимально простыми и понятными. Простота важнее, чем чрезмерная оптимизация, и, чем меньше сложных конструкций, тем легче поддерживать и расширять код. Основная идея KISS — избегать сложных решений, когда можно использовать простые и очевидные подходы.

DRY (Don't Repeat Yourself)
Принцип DRY утверждает, что каждый фрагмент знаний должен иметь одно, однозначное и авторитетное представление в системе. Повторение одного и того же кода следует избегать, так как это усложняет поддержку и увеличивает риск ошибок. Если повторяющийся код изменится, необходимо будет искать все места его использования и обновлять вручную, что увеличивает вероятность ошибок.

YAGNI (You Aren't Gonna Need It)
Этот принцип предостерегает от добавления в код функций, которые могут не понадобиться в будущем. Основная мысль YAGNI в том, что функциональность следует добавлять только в том случае, если она реально необходима. Излишняя функциональность увеличивает сложность кода, замедляет разработку и приводит к более частым ошибкам.

APO (Avoid Premature Optimization)
Принцип гласит, что не следует преждевременно заниматься оптимизацией кода. Стоит сначала завершить проектирование и получить работающую версию, а затем уже заниматься оптимизацией по мере необходимости. Оптимизация на ранних этапах разработки может привести к излишней сложности и снижению читаемости кода. Идея APO — не заниматься оптимизацией, пока это не станет действительно нужным.
